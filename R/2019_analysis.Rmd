---
title: "2019_analysis"
author: "Lachlan Baer"
date: "11/06/2019"
output: 
  html_document:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# R setup

```{r}
# Load libraries
library(plyr)
library(tidyverse)
library(edgeR)
library(AnnotationHub)
library(magrittr)
library(scales)
library(pander)
library(ggrepel)
library(fgsea)
library(pheatmap)
library(igraph)
library(tidygraph)
library(ggraph)
library(grid)
library(RUVSeq)
library(limma)
library(gganimate)
library(EDASeq)
```

```{r}
# Set working directory
setwd("~/Documents/Bioinformatics/Projects/20190122_Q96K97_NoStress_RNASeq/R")
```

```{r options}
theme_set(theme_bw())
panderOptions("table.split.table", Inf)
panderOptions("big.mark", ",")
panderOptions("table.style", "rmarkdown")
if (interactive()) setwd(here::here("R"))
```

# 2019 data analysis

## Differential Expression Analysis

### Load data

```{r}
# Load counts analysed by feature counts
counts <- read_tsv("../2_alignedData/featureCounts/genes.out") %>%
  set_colnames(basename(colnames(.))) %>%
  set_colnames(str_remove(colnames(.), "Aligned.sortedByCoord.out.bam")) %>%
  dplyr::select(Geneid, starts_with("W"), starts_with("Q"))
```

### Create DGEList

```{r}
# Create DGEList and calculate normalisaton factors
dgeList <- counts %>%
  as.data.frame() %>%
  column_to_rownames("Geneid") %>%
  DGEList() %>%
  calcNormFactors()
```

```{r}
# Set group variable
dgeList$samples$group <- colnames(dgeList) %>%
  str_extract("(W|Q)") %>%
  factor(levels = c("W", "Q"))
```

### Add gene information

```{r}
# Add AnnotationHub and subset to search for zebrafish
ah <- AnnotationHub()
ah %>%
  subset(species == "Danio rerio") %>%
  subset(dataprovider == "Ensembl") %>%
  subset(rdataclass == "EnsDb")
```

```{r}
# Select correct Ensembl release
ensDb <- ah[["AH64906"]]
```

```{r}
# Extract GenomicRanges object from ensDb
genesGR <- genes(ensDb)
```

```{r}
# Remove redundant columns from mcols
mcols(genesGR) <- mcols(genesGR)[c("gene_id", "gene_name", 
                                   "gene_biotype", "entrezid")]
```

```{r}
transGR <- transcripts(ensDb)
mcols(transGR) <- mcols(transGR)[c("tx_id", "gene_id")]
trans2Gene <- tibble(
  tx_id = transGR$tx_id,
  gene_id = transGR$gene_id
)
```

```{r}
# Add genesGR to DGEList using rownames of DGEList to reorder the genesGR
dgeList$genes <- genesGR[rownames(dgeList),]
```

### Data QC

```{r}
# Perform logical test to see how many genes were not detected in dataset
dgeList$counts %>%
  rowSums() %>%
  is_greater_than(0) %>%
  table()
```

```{r}
# Check for genes having > 4 samples with cpm > 1
dgeList %>%
  cpm() %>%
  is_greater_than(1) %>%
  rowSums() %>%
  is_weakly_greater_than(4) %>%
  table()
```

```{r}
# Create logical vector of genes to keep that fit criteria
genes2keep <- dgeList %>%
  cpm() %>%
  is_greater_than(1) %>%
  rowSums() %>%
  is_weakly_greater_than(4)
```

```{r}
# Create new DGEList of genes fitting criteria
dgeFilt <- dgeList[genes2keep,, keep.lib.sizes = FALSE] %>%
  calcNormFactors()
```

```{r fig.align = "center"}
# Compare distributions of the DGELists before and after filtering
par(mfrow = c(1,2))
dgeList %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "Before Filtering")
dgeFilt %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "After Filtering")
par(mfrow = c(1,1))
```

### Library sizes

```{r fig.align = "center"}
# Check library sizes with box plot
dgeFilt$samples %>%
  ggplot(aes(group, lib.size, fill = group)) +
  geom_boxplot() +
  scale_y_continuous(labels = comma) +
  labs(x = "Genotype", y = "Library size") +
  scale_fill_discrete(
    name ="Genotype", 
    labels = c("Wildtype", "Mutant")
  ) +
  scale_x_discrete(labels=c("W" = "Wildtype", "Q" = "Mutant")) +
  theme_bw()
```

### PCA

```{r}
# Assess cpm values to make sure PCA results are not heavily skewed by highly expressed genes
pca <- dgeFilt %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

```{r}
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pca)$importance %>% pander(split.tables = Inf)
```

```{r fig.align = "center"}
# Plot PCA
pca$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFilt$samples, "sample")) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample)) +
  geom_point(alpha = 0.8, size = 3) +
  geom_text_repel(show.legend = FALSE) +
  labs(
    x = paste0("PC1 (", percent(summary(pca)$importance[2, "PC1"]), ")"),
    y = paste0("PC2 (", percent(summary(pca)$importance[2, "PC2"]), ")"),
    colour = "Genotype"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant"))
```

### Differential expression

```{r}
# Create model matrix
design <- model.matrix(~group, data = dgeFilt$samples)
```

```{r}
# Perform exact test on DGEList
topTable <- dgeFilt %>%
  estimateDisp(design = design) %>%
  exactTest() %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r BL FDR, eval=FALSE, include=FALSE}
# BL FDR
designBL <- model.matrix(~ logCPM, data = topTable$table)
BL <- lm_pi0(topTable$table$PValue, X = designBL) 
BLvalue <- BL$pi0 * topTable$table$FDR
BLtopTable <- topTable$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(Geneid = ID.gene_id, 
                Symbol = ID.gene_name,
                AveExpr = logCPM, logFC, 
                P.Value = PValue, 
                FDR, Location, 
                Entrez = ID.entrezid) %>%
  mutate(BLvalue = BLvalue) %>%
  mutate(DE = BLvalue < 0.05) %>%
  dplyr::arrange(BLvalue)
```

```{r IHW FDR, eval=FALSE, include=FALSE}
# IHW FDR
IHWvalue <- ihw(topTable$table$PValue, 
                covariates = topTable$table$logCPM, 
                alpha = 0.05) %>%
  adj_pvalues()

IHWtopTable <- topTable$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(Geneid = ID.gene_id, 
                Symbol = ID.gene_name,
                AveExpr = logCPM, logFC, 
                P.Value = PValue, 
                FDR, Location, 
                Entrez = ID.entrezid) %>%
  mutate(IHWvalue = IHWvalue) %>%
  mutate(DE = IHWvalue < 0.05) %>%
  dplyr::arrange(IHWvalue)  
```

```{r fig.align = "center"}
# Volcano plot showing DE genes
topTable %>%
  ggplot(aes(logFC, -log10(P.Value), colour = DE)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(data = . %>% 
                    dplyr::filter(DE) %>%
                    dplyr::filter(-log10(P.Value) > 4 | abs(logFC) >                        2.5), aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey50", "red")) +
  labs(x = "logFC", y = expression(paste(-log[10], "(p)"))) +
  theme_bw() +
  theme(legend.position = "none")
```

```{r fig.align = "center"}
# MD Plot showing DE genes
topTable %>%
  dplyr::arrange(desc(P.Value)) %>%
  ggplot(aes(AveExpr, logFC, colour = DE)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(
    data = . %>% 
      dplyr::filter(DE) %>%
      dplyr::filter(abs(logFC) > 2 | AveExpr > 14),
    aes(label = Symbol)
  ) + 
  scale_colour_manual(values = c("grey", "red")) +
  labs(x = "Average Expression (log2 CPM)",
       y = "log Fold-Change") +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
# Summary of DE genes
topTableDE <- topTable %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) 
topTableDE %>% pander(style = "rmarkdown", split.tables = Inf)
```

## GO Enrichment

```{r}
ens2Entrez <- file.path("https://uofabioinformaticshub.github.io/Intro-NGS-fib",
                        "data", "ens2Entrez.tsv") %>% 
  url() %>%
  read_tsv()
```

```{r}
de <- topTable %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid) %>%
  left_join(ens2Entrez) %>%
  dplyr::filter(!is.na(Entrez)) %>%
  .[["Entrez"]] %>%
  unique()
uv <- topTable %>%
  dplyr::select(Geneid) %>%
  left_join(ens2Entrez) %>%
  dplyr::filter(!is.na(Entrez)) %>%
  .[["Entrez"]] %>%
  unique()
```

```{r}
goResults <- goana(de = de, universe = uv, species = "Hs")
```

```{r}
goResults %>% 
  rownames_to_column("GO ID") %>%
  as_tibble() %>%
  dplyr::filter(DE > 1) %>%
  dplyr::arrange(P.DE) %>%
  mutate(FDR = p.adjust(P.DE, "fdr")) %>%
  dplyr::filter(FDR < 0.05) %>%
  mutate(`GO ID` = str_replace(`GO ID`, ":", "\\\\:")) %>%
  pander(caption = "GO Terms potentially enriched in the set of differentially expressed genes")
```

## Gene Set Enrichment Analysis (GSEA)

### Setting up ID conversion, ranks and pathways

```{r}
# Load id conversion file
idConvert <- read_csv2("../files/zf2human_withEntrezIDs.csv") %>%
  dplyr::select(Geneid = zfID, EntrezID = Entrez) %>%
  mutate(EntrezID = as.character(EntrezID))
# Create function to convert ids (Not sure how this works, Steve wrote it)
convertHsEG2Dr <- function(ids, df = idConvert){
  dplyr::filter(df, EntrezID %in% ids)$Geneid
}
# Conversion of zebrafish ensembl ID to zebrafish symbol, for plotting on network analyses
idConvertSymbol <- read_csv2("../files/zf2human_withEntrezIDs.csv") %>%
  dplyr::select(label = zfID, symbol = zfName) %>%
  na.omit() %>%
  unique()
```

```{r}
# Create named vector of gene level statistics 
ranks <- topTable %>%
  mutate(stat = -sign(logFC) * log10(P.Value)) %>%
  dplyr::arrange(stat) %>%
  with(structure(stat, names = Geneid))
```

```{r}
# Import hallmark human gene genesets and tidy gene set names
# .gmt files downloaded from:
# http://software.broadinstitute.org/gsea/downloads.jsp 
# http://data.wikipathways.org/20190610/ 
hallmark <- gmtPathways("../files/h.all.v6.2.entrez.gmt") %>%
  mclapply(convertHsEG2Dr, mc.cores = 4) %>%
  set_names(str_remove_all(names(.), "HALLMARK_"))
kegg <- gmtPathways("../files/c2.cp.kegg.v6.2.entrez.gmt") %>%
  mclapply(convertHsEG2Dr, mc.cores = 4) %>%
  set_names(str_remove_all(names(.), "KEGG_"))
wiki <- gmtPathways("../files/wikipathways-20190610-gmt-Homo_sapiens.gmt") %>%
  mclapply(convertHsEG2Dr, mc.cores = 4) %>%
  set_names(str_remove_all(names(.), "%.+"))
```

### Hallmark

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for hallmark
fgseaHallmark <- fgsea(hallmark, ranks, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaHallmarkTop <- fgseaHallmark %>%
  dplyr::filter(padj < 0.05)
fgseaHallmarkTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched Hallmark pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant Hallmark pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(
  hallmark[fgseaHallmarkTop$pathway], ranks, fgseaHallmark, gseaParam = 0.5
)
```

```{r}
# Create enrichment plot for oxphos
plotEnrichment(
  hallmark[["OXIDATIVE_PHOSPHORYLATION"]], ranks
) + 
  labs(title = "OXIDATIVE PHOSPHORYLATION") +
  theme(
    panel.grid.major = element_blank())
```

```{r heatmapHallmark, eval=FALSE, include=FALSE}
# Create heatmap of genes in Hallmark oxphos pathway
Hallmark_oxphos <- hallmark$OXIDATIVE_PHOSPHORYLATION %>% 
  as_tibble() %>%
  dplyr::rename(EntrezID = value) %>%
  dplyr::mutate_at(1, as.double) %>%
  left_join(id_convert, by = "EntrezID") %>%
  dplyr::select("Geneid") %>%
  na.omit() %>%
  pull(Geneid)
dgeFilt %>%
  cpm(log = TRUE) %>%
  as.data.frame() %>%
  dplyr::select(c("W1", "W2", "W3", "W4", "W5", 
                  "Q1", "Q2", "Q4", "Q5")) %>%
  .[which(rownames(.) %in% Hallmark_oxphos), ] %>%
  t() %>%
  pheatmap(cluster_rows = FALSE, cluster_cols = FALSE,
           gaps_row = 5, show_colnames = FALSE, fontsize = 9,
           fontsize_row = 10, border_color = NA,
           main = "Expression levels of genes in Hallmark oxidative phosphorylation pathway")
```

### KEGG

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for KEGG
fgseaKEGG <- fgsea(kegg, ranks, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaKEGGTop <- fgseaKEGG %>%
  dplyr::filter(padj < 0.05)
fgseaKEGGTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched KEGG pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant KEGG pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(
  kegg[fgseaKEGGTop$pathway], ranks, fgseaKEGG, gseaParam = 0.5
)
```

```{r heatmapKEGG, eval=FALSE, include=FALSE}
# Create heatmap of genes in KEGG oxphos pathway
KEGG_oxphos <- kegg$OXIDATIVE_PHOSPHORYLATION %>% 
  as_tibble() %>%
  dplyr::rename(EntrezID = value) %>%
  dplyr::mutate_at(1, as.double) %>%
  left_join(id_convert, by = "EntrezID") %>%
  dplyr::select("Geneid") %>%
  na.omit() %>%
  pull(Geneid)
dgeFilt %>%
  cpm(log = TRUE) %>%
  as.data.frame() %>%
  dplyr::select(c("W1", "W2", "W3", "W4", "W5", 
                  "Q1", "Q2", "Q4", "Q5")) %>%
  .[which(rownames(.) %in% KEGG_oxphos), ] %>%
  t() %>%
  pheatmap(cluster_rows = FALSE, cluster_cols = FALSE,
           gaps_row = 5, show_colnames = FALSE, fontsize = 9,
           fontsize_row = 10, border_color = NA,
           main = "Expression levels of genes in KEGG oxidative phosphorylation pathway")
```

### WikiPathways

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for WikiPathways
fgseaWiki <- fgsea(wiki, ranks, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaWikiTop <- fgseaWiki %>%
  dplyr::filter(padj < 0.05)
fgseaWikiTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched Wiki pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant WikiPathways pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(
  wiki[fgseaWikiTop$pathway], ranks, fgseaWiki, gseaParam = 0.5
)
```

```{r heatmapWiki, eval=FALSE, include=FALSE}
# Create heatmap of genes in WikiPathways oxphos pathway
Wiki_oxphos <- wiki$`Oxidative phosphorylation` %>% 
  as_tibble() %>%
  dplyr::rename(EntrezID = value) %>%
  dplyr::mutate_at(1, as.double) %>%
  left_join(id_convert, by = "EntrezID") %>%
  dplyr::select("Geneid") %>%
  na.omit() %>%
  pull(Geneid)
dgeFilt %>%
  cpm(log = TRUE) %>%
  as.data.frame() %>%
  dplyr::select(c("W1", "W2", "W3", "W4", "W5", 
                  "Q1", "Q2", "Q4", "Q5")) %>%
  .[which(rownames(.) %in% Wiki_oxphos), ] %>%
  t() %>%
  pheatmap(cluster_rows = FALSE, cluster_cols = FALSE,
           gaps_row = 5, show_colnames = FALSE, fontsize = 9,
           fontsize_row = 10, border_color = NA,
           main = "Expression levels of genes in WikiPathways oxidative phosphorylation pathway")
```

### Closer look

```{r}

```

## Fry

### Hallmark

```{r}
# Create design matrix
design <- model.matrix(~group, data = dgeFilt$samples)
# Create voom object
voom <- voom(dgeFilt, design)
```

```{r}
# Create index for fry
fryIndex <- ids2indices(hallmark, rownames(dgeFilt$counts))
```

```{r}
# Run fry
fry(voom, index = fryIndex, design = design) %>%
  rownames_to_column("pathway") %>%
  dplyr::arrange(PValue.Mixed) %>%
  as.data.frame() %>%
  column_to_rownames("pathway") 
```

## Network Analysis

### Hallmark

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigHallmark <-
  fgseaHallmarkTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>% 
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysHallmark <- names(sigHallmark) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesHallmark <- unique(unlist(sigHallmark)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesHallmark <- full_join(pathwaysHallmark, genesHallmark, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesHallmark <- ldply(sigHallmark, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesHallmark, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesHallmark, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyHallmark <- 
  tbl_graph(nodes = nodesHallmark, edges = edgesHallmark, directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaHallmarkTop) ~ label
    ),
    DE = case_when(
      label %in% topTableDE$Geneid ~ symbol
    ),
    size = case_when(
      label %in% topTable$Geneid ~ 
        as.integer(row_number(label %in% topTable$Geneid)), 
      id <= nrow(fgseaHallmarkTop) ~ as.integer(4000)
    ),
    colour = case_when(
      id <= nrow(fgseaHallmarkTop) ~ rainbow(nrow(fgseaHallmarkTop))[id],
      label %in% topTableDE$Geneid ~ "black"
    ),
    hjust = case_when(
      DE == "ugt5b4" ~ as.integer(0)
    ),
    vjust = case_when(
      DE == "ugt5b4" ~ as.integer(5)
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaHallmarkTop) ~ rainbow(nrow(fgseaHallmarkTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(22)
# Plot graph
ggraph(tidyHallmark, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaHallmarkTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour), 
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour),
    shape = 21,
    stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways),
    repel = TRUE,
    size = 3, 
    alpha = 0.7,
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE, hjust = hjust, vjust = vjust),
    repel = TRUE,
    size = 3,
    alpha = 0.8,
    colour = "black"
  ) +
  theme_graph() +
  theme(legend.position = "none")
```

### KEGG

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigKEGG <- 
  fgseaKEGGTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>%
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysKEGG <- names(sigKEGG) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesKEGG <- unique(unlist(sigKEGG)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesKEGG <- full_join(pathwaysKEGG, genesKEGG, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesKEGG <- ldply(sigKEGG, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesKEGG, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesKEGG, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyKEGG <- 
  tbl_graph(nodes = nodesKEGG, edges = edgesKEGG, directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaKEGGTop) ~ label
    ),
    DE = case_when(label %in% topTableDE$Geneid ~ symbol),
    size = case_when(
      label %in% topTable$Geneid ~ row_number(label %in% topTable$Geneid), 
      id <= nrow(fgseaKEGGTop) ~ 4000L
    ) %>% as.integer(),
    colour = case_when(
      id <= nrow(fgseaKEGGTop) ~ rainbow(nrow(fgseaKEGGTop))[id],
      label %in% topTableDE$Geneid ~ "black"
    ),
    hjust = case_when(
      DE == "ugt5b4" ~ -1L,
      DE == "blvrb" ~ 7L
    ),
    vjust = case_when(
      DE == "ugt5b4" ~ 7L,
      DE == "blvrb" ~ 0L
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaKEGGTop) ~ rainbow(nrow(fgseaKEGGTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(26)
# Plot graph
ggraph(tidyKEGG, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaKEGGTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour), 
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour), 
    shape = 21, 
    stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways),
    repel = TRUE, 
    size = 3, 
    alpha = 0.7, 
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE, hjust = hjust, vjust = vjust), 
    repel = TRUE,
    size = 3,
    alpha = 0.8, 
    colour = "black"
  ) +
  theme_graph() +
  theme(legend.position = "none")
```

### WikiPathways

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigWiki <- 
  fgseaWikiTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>% 
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysWiki <- names(sigWiki) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesWiki <- unique(unlist(sigWiki)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesWiki <- full_join(pathwaysWiki, genesWiki, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesWiki <- ldply(sigWiki, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesWiki, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesWiki, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyWiki <- 
  tbl_graph(nodes = nodesWiki, edges = edgesWiki, directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaWikiTop) ~ label
    ),
    DE = case_when(
      label %in% topTableDE$Geneid ~ symbol
    ),
    size = case_when(
      label %in% topTable$Geneid ~ 
        as.integer(row_number(label %in% topTable$Geneid)), 
      id <= nrow(fgseaWikiTop) ~ as.integer(4000)
    ),
    colour = case_when(
      id <= nrow(fgseaWikiTop) ~ rainbow(nrow(fgseaWikiTop))[id],
      label %in% topTableDE$Geneid ~ "black"
    ),
    hjust = case_when(
      DE == "ugt5b4" ~ as.integer(1),
      DE == "blvrb" ~ as.integer(2)
    ),
    vjust = case_when(
      DE == "ugt5b4" ~ as.integer(7),
      DE == "blvrb" ~ as.integer(7)
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaWikiTop) ~ rainbow(nrow(fgseaWikiTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(27)
# Plot graph
ggraph(tidyWiki, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaWikiTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour), 
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour), 
    shape = 21, 
    stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.7, 
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE, hjust = hjust, vjust = vjust), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.8, 
    colour = "black"
  ) +
  theme_graph() +
  theme(legend.position = "none")
```

## Gene removal

```{r}
# # Create table of gene GC content and length
# # This is extremely slow, takes approximately 30 minutes.
# # Saved as .rds file to save time
# id2019 <- rownames(dgeFilt)
# geneGCLen2019 <- getGeneLengthAndGCContent(id2019, org = "dre", mode = "biomart")
# saveRDS(geneGCLen2019, "../files/geneGCLen2019.rds")
```

```{r}
geneGCLen2019 <- readRDS("../files/geneGCLen2019.rds") %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  as_tibble()
```

```{r}
# Filter for genes that have short length and high GC content.
# To be used for subsetting filtered dgeList
geneFilter2019 <- geneGCLen2019 %>%
  mutate(
    minLenTest = length > 1000,
    maxLenTest = length < 7600,
    gcTest = gc < 0.498
  ) %>%
  dplyr::filter(minLenTest, maxLenTest, gcTest)
```

```{r}
# Subset filtered dgeList
dgeRemoved2019 <- dgeFilt[geneFilter$gene_id,]
```

### PCA

```{r}
# Assess cpm values to make sure PCA results are not heavily skewed by highly expressed genes
pcaRemoved2019 <- dgeRemoved2019 %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

```{r fig.align = "center"}
# Create PCA plots
pcaRemoved2019$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeRemoved2019$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, -PC2, colour = group, label = sample)) +
  geom_point(alpha = 0.8, size = 3) +
  geom_text_repel(show.legend = FALSE) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRemoved2019)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRemoved2019)$importance[2,"PC2"]), ")"),
    colour = "Genotype"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant")) +
  theme_bw()
```

## RUVg

### k = 1

```{r}
# Extract subset of low expressed genes from DE analysis to act as negative controls for RUVg procedure
negControl <- topTable %>% 
  dplyr::arrange(desc(P.Value)) %>%
  .[1:10000,] %>%
  .$Geneid
```

```{r}
# Run RUVSeq
RUVg <- RUVg(dgeFilt$counts, negControl, 1)
```

### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalse <- dgeFilt
# Replace with results
dgeFalse$counts <- RUVg$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVg <- dgeFalse %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVg)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVg$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalse$samples, "sample")) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample)) +
  geom_point() +
  geom_text_repel(show.legend = FALSE) +
  theme_bw()
```

### DE Analysis

```{r}
# Create copy of DGE List 
dgeRUVg <- dgeFilt
# Bind W_1 from RUVSeq analysis to $samples 
dgeRUVg$samples %<>% cbind(RUVg$W)
# Create design matrix
design <- model.matrix(~group + W_1, data = dgeRUVg$samples)
# Perform DE analysis
topTableRUVg <- estimateGLMCommonDisp(dgeRUVg, design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef=2) %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r}
# Summary of DE genes
topTableRUVg %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) %>% 
  pander(style = "rmarkdown", split.tables = Inf)
```

## RUVs

```{r}
differences2019 <- makeGroups(dgeFilt$samples$group)
```

```{r}
RUVs2019 <- RUVs(dgeFilt$counts, negControl, k = 2, differences2019)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseRUVs2019 <- dgeFilt
# Replace with results
dgeFalseRUVs2019$counts <- RUVs2019$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVs2019 <- dgeFalseRUVs2019 %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVs2019)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVs2019$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseRUVs2019$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample)) +
  geom_text_repel(show.legend = FALSE) +
  geom_point(size = 3, alpha = 0.8) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVs2019)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVs2019)$importance[2,"PC2"]), ")"),
    colour = "Genotype"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant")) +
  theme_bw()
```

### DE Analysis

```{r}
# Create copy of DGE List 
dgeRUVs2019 <- dgeFilt
# Bind W_1 from RUVSeq analysis to $samples 
dgeRUVs2019$samples %<>% cbind(RUVs2019$W)
# Create design matrix
design <- model.matrix(~group + W_1 + W_2, 
                       data = dgeRUVs2019$samples)
# Perform DE analysis
topTableRUVs2019 <- estimateGLMCommonDisp(dgeRUVs2019, design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef=2) %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r}
# Summary of DE genes
topTableRUVs2019DE <- topTableRUVs2019 %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR)
topTableRUVs2019DE %>% 
  pander(style = "rmarkdown", split.tables = Inf)
```

```{r}
# Check CPM values for DE genes
DERUVs2019 <- topTableRUVs2019 %>%
  dplyr::filter(FDR < 0.05) %>%
  .$Geneid
dgeFilt$counts %>% cpm() %>% .[DERUVs2019,] %>% as.data.frame() %>% dplyr::select(str_subset(colnames(.), "Q.+"), str_subset(colnames(.), "W.+")) %>% round(digits = 2) %>% pander()
```

```{r}
# Volcano plot showing DE genes
topTableRUVs2019 %>%
  ggplot(aes(logFC, -log10(P.Value), colour = DE)) +
  geom_point(alpha = 0.5) +
  # geom_text_repel(data = . %>% 
  #                   dplyr::filter(DE) %>%
  #                   dplyr::filter(-log10(P.Value) > 4 | abs(logFC) >                        2.5), aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey50", "red")) +
  labs(x = "logFC", y = expression(paste(-log[10], "(p)"))) +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
# Test whether DE genes fall into bins of concern
GCLenTest2019 <- tibble(DERUVs2019) %>%
  dplyr::rename(gene_id = DERUVs2019) %>%
  left_join(geneGCLen2019) %>%
  na.omit() %>%
  dplyr::mutate(
    minLenTest = length > 1000,
    maxLenTest = length < 7600,
    gcTest = gc < 0.498
  )
# Number of genes with length < 1000
GCLenTest2019 %>%
  dplyr::filter(minLenTest) %>%
  nrow()
# Number of genes with length > 7600
GCLenTest2019 %>%
  dplyr::filter(maxLenTest) %>%
  nrow()
# Number of genes with GC < 0.498
GCLenTest2019 %>%
  dplyr::filter(gcTest) %>%
  nrow()
# Number of genes that satisfy all three criteria
GCLenTest2019 %>%
  dplyr::filter(minLenTest, maxLenTest, gcTest) %>%
  nrow()
```

# 2017 data analysis

## Differential Expression Analysis

### Load data

```{r}
kalCounts <- read_rds("nhiData/6month_Normoxia.rds")
dgeListNhi <- kalCounts$counts %>%
  as.data.frame() %>%
  rownames_to_column("tx_id") %>%
  as_tibble() %>%
  set_colnames(basename(colnames(.))) %>%
  mutate(tx_id = str_remove_all(tx_id, "\\.[0-9]*$")) %>%
  left_join(trans2Gene) %>%
  group_by(gene_id) %>%
  summarise_if(
    .predicate = is.numeric,
    .funs = sum
    ) %>%
  as.data.frame() %>%
  column_to_rownames("gene_id") %>%
  round() %>%
  set_colnames(str_remove(colnames(.), "[0-9]_MORGAN_6")) %>%
  set_colnames(str_remove(colnames(.), "PN")) %>%
  set_colnames(str_remove(colnames(.), "_[RS].+")) %>%
  set_colnames(str_replace(colnames(.), "P", "W")) %>%
  DGEList(
    group = colnames(.) %>%
      str_replace_all("([WQ])(.+)", "\\1") %>%
      str_replace_all("W", "WT") %>%
      str_replace_all("Q", "Mut") %>%
      factor(levels = c("WT", "Mut")),
    genes = genesGR[rownames(.)]
  ) %>%
  calcNormFactors() 
```


### Data QC

```{r}
# Perform logical test to see how many genes were not detected in dataset
dgeListNhi$counts %>%
  rowSums() %>%
  is_greater_than(0) %>%
  table()
```

```{r}
# Check for genes having >= 4 samples with cpm > 1
dgeListNhi %>%
  cpm() %>%
  is_greater_than(1) %>%
  rowSums() %>%
  is_weakly_greater_than(4) %>%
  table()
```

```{r}
# Create logical vector of genes to keep that fit criteria
genes2keepNhi <- dgeListNhi %>%
  cpm() %>%
  is_greater_than(1) %>%
  rowSums() %>%
  is_weakly_greater_than(4)
```

```{r}
# Create new DGEList of genes fitting criteria
dgeFiltNhi <- dgeListNhi[genes2keepNhi,, keep.lib.sizes = FALSE] %>%
  calcNormFactors()
```

```{r fig.align = "center"}
# Compare distributions of the DGELists before and after filtering
par(mfrow = c(1,2))
dgeListNhi %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "Before Filtering")
dgeFiltNhi %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "After Filtering")
par(mfrow = c(1,1))
```

### Library sizes

```{r fig.align = "center"}
# Check library sizes with box plot
dgeFiltNhi$samples %>%
  ggplot(aes(group, lib.size, fill = group)) +
  geom_boxplot() +
  scale_y_continuous(labels = comma) +
  labs(x = "Genotype", y = "Library Size") +
  scale_fill_discrete(
    name ="Genotype", 
    labels = c("Wildtype","Mutant")
  ) +
  scale_x_discrete(labels=c("w" = "Wildtype", "q" = "Mutant")) +
  theme_bw()
```

### PCA

```{r}
# Assess cpm values to make sure PCA results are not heavily skewed by highly expressed genes
pcaNhi <- dgeFiltNhi %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

```{r}
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaNhi)$importance %>% pander(split.tables = Inf)
```

```{r fig.align = "center"}
# Plot PCA
pcaNhi$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFiltNhi$samples, "sample")) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample)) +
  geom_point() +
  geom_text_repel(show.legend = FALSE) +
  theme_bw()
```

### Differential expression

```{r}
# Create model matrix
design <- model.matrix(~group, data = dgeFiltNhi$samples)
```

```{r}
# Perform exact test on DGEList
topTableNhi <- dgeFiltNhi %>%
  estimateDisp(design = design) %>%
  exactTest() %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", start, end, sep = "-") %>%
  unite("Location", seqnames, Range, strand, sep = ":") %>%
  dplyr::select(Geneid = gene_id, 
                Symbol = gene_name,
                AveExpr = logCPM, logFC, 
                P.Value = PValue, 
                FDR, Location, 
                Entrez = entrezid) %>%
  mutate(DE = FDR < 0.05)
```

```{r fig.align = "center"}
# Volcano plot showing DE genes
topTableNhi %>%
  ggplot(aes(logFC, -log10(P.Value), colour = DE)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(data = . %>% 
                    dplyr::filter(DE) %>%
                    dplyr::filter(-log10(P.Value) > 4 | abs(logFC) >                        2.5), aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey", "red")) +
  theme_bw() +
  theme(legend.position = "none")
```

```{r fig.align = "center"}
# MD Plot showing DE genes
topTableNhi %>%
  dplyr::arrange(desc(P.Value)) %>%
  ggplot(aes(AveExpr, logFC, colour = DE)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(data = . %>% 
                    dplyr::filter(DE) %>%
                    dplyr::filter(abs(logFC) > 2 | AveExpr > 14),
                  aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey", "red")) +
  labs(x = "Average Expression (log2 CPM)",
       y = "log Fold-Change") +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
# Summary of DE genes
topTableDENhi <- topTableNhi %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) 
topTableDENhi %>% pander(style = "rmarkdown", split.tables = Inf)
```

## Gene Set Enrichment Analysis (GSEA)

```{r}
# Create named vector of gene level statistics 
ranksNhi <- topTableNhi %>%
  mutate(stat = -sign(logFC) * log10(P.Value)) %>%
  dplyr::arrange(stat) %>%
  with(structure(stat, names = Geneid))
```

### Hallmark

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for hallmark
fgseaHallmarkNhi <- fgsea(hallmark, ranksNhi, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaHallmarkNhiTop <- fgseaHallmarkNhi %>%
  dplyr::filter(padj < 0.05)
fgseaHallmarkNhiTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched Hallmark pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant Hallmark pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(hallmark[fgseaHallmarkNhiTop$pathway], 
              ranksNhi, fgseaHallmarkNhi, gseaParam = 0.5)
```

### KEGG

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for hallmark
fgseaKEGGNhi <- fgsea(kegg, ranksNhi, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaKEGGNhiTop <- fgseaKEGGNhi %>%
  dplyr::filter(padj < 0.05)
fgseaKEGGNhiTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched KEGG pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant Hallmark pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(kegg[fgseaKEGGNhiTop$pathway], 
              ranksNhi, fgseaKEGGNhi, gseaParam = 0.5)
```

### Wikipathways

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for hallmark
fgseaWikiNhi <- fgsea(wiki, ranksNhi, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
# Create an object of pathways with adjusted p-value < 0.05 for construction of network diagrams. This should be done differently next time, but too much work has been done to change it now.
fgseaWikiNhiTop <- fgseaWikiNhi %>%
  dplyr::filter(padj < 0.05)
fgseaWikiNhiTop %>%
  dplyr::select(-leadingEdge, -nMoreExtreme) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched Wiki pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

```{r fig.align = "center"}
# Make a table plot of significant Hallmark pathways
if (interactive()) grid::grid.newpage()
plotGseaTable(wiki[fgseaWikiNhiTop$pathway], 
              ranksNhi, fgseaWikiNhi, gseaParam = 0.5)
```

## Fry

### Hallmark

```{r}
# Create design matrix
design <- model.matrix(~group, data = dgeFiltNhi$samples)
# Create voom object
voomNhi <- voom(dgeFiltNhi, design)
```

```{r}
# Create index for fry
fryIndexNhi <- ids2indices(hallmark, rownames(dgeFiltNhi$counts))
```

```{r}
# Run fry
fry(voomNhi, index = fryIndexNhi, design = design) %>%
  rownames_to_column("pathway") %>%
  dplyr::arrange(PValue.Mixed) %>%
  as.data.frame() %>%
  column_to_rownames("pathway") 
```

## Network Analysis


### Hallmark

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigHallmarkNhi <-
  fgseaHallmarkNhiTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>% 
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysHallmarkNhi <- names(sigHallmarkNhi) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesHallmarkNhi <- unique(unlist(sigHallmarkNhi)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesHallmarkNhi <- full_join(pathwaysHallmarkNhi, genesHallmarkNhi, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesHallmarkNhi <- ldply(sigHallmarkNhi, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesHallmarkNhi, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesHallmarkNhi, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyHallmarkNhi <- 
  tbl_graph(nodes = nodesHallmarkNhi, 
            edges = edgesHallmarkNhi, 
            directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaHallmarkNhiTop) ~ label
    ),
    DE = case_when(
      label %in% topTableDENhi$Geneid ~ symbol
    ),
    size = case_when(
      label %in% topTableNhi$Geneid ~ 
        as.integer(row_number(label %in% topTableNhi$Geneid)), 
      id <= nrow(fgseaHallmarkNhiTop) ~ as.integer(4000)
    ),
    colour = case_when(
      id <= nrow(fgseaHallmarkNhiTop) ~ rainbow(nrow(fgseaHallmarkNhiTop))[id],
      label %in% topTableDENhi$Geneid ~ "black"
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaHallmarkNhiTop) ~ 
        rainbow(nrow(fgseaHallmarkNhiTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(22)
# Plot graph
ggraph(tidyHallmarkNhi, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaHallmarkNhiTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour),
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour), 
    shape = 21, stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways), 
    repel = TRUE, size = 3, 
    alpha = 0.7, 
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.8, 
    colour = "black"
  ) +
  theme_graph() +
  theme(legend.position = "none")
```

### KEGG

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigKEGGNhi <-
  fgseaKEGGNhiTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>% 
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysKEGGNhi <- names(sigKEGGNhi) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesKEGGNhi <- unique(unlist(sigKEGGNhi)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesKEGGNhi <- full_join(pathwaysKEGGNhi, genesKEGGNhi, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesKEGGNhi <- ldply(sigKEGGNhi, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesKEGGNhi, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesKEGGNhi, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyKEGGNhi <- 
  tbl_graph(nodes = nodesKEGGNhi, edges = edgesKEGGNhi, directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaKEGGNhiTop) ~ label
    ),
    DE = case_when(
      label %in% topTableDENhi$Geneid ~ symbol
    ),
    size = case_when(
      label %in% topTableNhi$Geneid ~ 
        as.integer(row_number(label %in% topTableNhi$Geneid)), 
      id <= nrow(fgseaKEGGNhiTop) ~ as.integer(4000)
    ),
    colour = case_when(
      id <= nrow(fgseaKEGGNhiTop) ~ rainbow(nrow(fgseaKEGGNhiTop))[id],
      label %in% topTableDENhi$Geneid ~ "black"
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaKEGGNhiTop) ~ rainbow(nrow(fgseaKEGGNhiTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(22)
# Plot graph
ggraph(tidyKEGGNhi, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaKEGGNhiTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour), 
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour), 
    shape = 21, 
    stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.7, 
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.8, 
    colour = "black"
  ) +
  theme_graph() +
  theme(legend.position = "none")
```

### Wikipathways

```{r}
# Load significant pathways with ONLY leading edge genes determined from GSEA analysis
sigWikiNhi <-
  fgseaWikiNhiTop %>%
  split(f = .$pathway) %>% 
  lapply(extract2, "leadingEdge") %>% 
  lapply(unlist)
```

```{r}
# Create a node list
pathwaysWikiNhi <- names(sigWikiNhi) %>%
  as.data.frame() %>%
  set_colnames("label") %>%
  mutate(label = as.character(label))
genesWikiNhi <- unique(unlist(sigWikiNhi)) %>% 
  as.data.frame() %>% 
  set_colnames("label") %>%
  mutate(label = as.character(label))
nodesWikiNhi <- full_join(pathwaysWikiNhi, genesWikiNhi, by = "label") %>%
  rowid_to_column("id")
# Then create an edge list
edgesWikiNhi <- ldply(sigWikiNhi, data.frame) %>% 
  set_colnames(c("pathway", "gene")) %>%
  mutate(gene = as.character(gene)) %>%
  left_join(nodesWikiNhi, by = c("pathway" = "label")) %>%
  dplyr::rename(from = id) %>%
  left_join(nodesWikiNhi, by = c("gene" = "label")) %>%
  dplyr::rename(to = id) %>%
  dplyr::select(from, to)
```

```{r fig.align = "center"}
# Create tidygraph object
tidyWikiNhi <- 
  tbl_graph(nodes = nodesWikiNhi, edges = edgesWikiNhi, directed = FALSE) %>%
  activate(nodes) %>%
  left_join(idConvertSymbol, by = "label") %>%
  mutate(
    pathways = case_when(
      id <= nrow(fgseaWikiNhiTop) ~ label
    ),
    DE = case_when(
      label %in% topTableDENhi$Geneid ~ symbol
    ),
    size = case_when(
      label %in% topTableNhi$Geneid ~ 
        as.integer(row_number(label %in% topTableNhi$Geneid)), 
      id <= nrow(fgseaWikiNhiTop) ~ as.integer(4000)
    ),
    colour = case_when(
      id <= nrow(fgseaWikiNhiTop) ~ rainbow(nrow(fgseaWikiNhiTop))[id],
      label %in% topTableDENhi$Geneid ~ "black"
    )
  ) %>%
  activate(edges) %>%
  mutate(
    colour = case_when(
      from <= nrow(fgseaWikiNhiTop) ~ rainbow(nrow(fgseaWikiNhiTop))[from]
    )
  )
# Set seed to enable reproducibility (seed selected to create graph with non-overlapping labels)
set.seed(22)
# Plot graph
ggraph(tidyWikiNhi, layout = "fr") +
  scale_fill_manual(
    values = c(rainbow(nrow(fgseaWikiNhiTop)), "black"), 
    na.value = "gray80"
  ) +
  geom_edge_arc(
    aes(color = colour),
    alpha = 0.5, 
    show.legend = FALSE, 
    curvature = 0.5
  ) +
  geom_node_point(
    aes(size = size, fill = colour), 
    shape = 21, 
    stroke = 0.5, 
    show.legend = FALSE
  ) +
  geom_node_label(
    aes(label = pathways), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.7, 
    label.padding = 0.1
  ) +
  geom_node_text(
    aes(label = DE), 
    repel = TRUE, 
    size = 3, 
    alpha = 0.8, 
    colour = "black") +
  theme_graph() +
  theme(legend.position = "none")
```

## RUVg

### k = 1

```{r}
# Extract subset of low expressed genes from DE analysis to act as negative controls for RUVg procedure
negControlNhi <- topTableNhi %>% 
  dplyr::arrange(desc(P.Value)) %>%
  .[1:10000,] %>%
  .$Geneid
```

```{r}
# Run RUVSeq
RUVgNhi <- RUVg(dgeFiltNhi$counts, negControlNhi, 1)
```

### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseNhi <- dgeFiltNhi
# Replace with results
dgeFalse$counts <- RUVgNhi$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgNhi <- dgeFalseNhi %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgNhi)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgNhi$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseNhi$samples, "sample")) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample)) +
  geom_point() +
  geom_text_repel(show.legend = FALSE) +
  theme_bw()
```

### DE Analysis

```{r}
# Create copy of DGE List 
dgeRUVgNhi <- dgeFiltNhi
# Bind W_1 from RUVSeq analysis to $samples 
dgeRUVgNhi$samples %<>% cbind(RUVgNhi$W)
# Create design matrix
design <- model.matrix(~group + W_1, data = dgeRUVgNhi$samples)
# Perform DE analysis
topTableRUVgNhi <- estimateGLMCommonDisp(dgeRUVgNhi, design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef=2) %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", start, end, sep = "-") %>%
  unite("Location", seqnames, Range, strand, sep = ":") %>%
  dplyr::select(
    Geneid = gene_id, 
    Symbol = gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r}
# Summary of DE genes
topTableRUVgNhi %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) %>% 
  pander(style = "rmarkdown", split.tables = Inf)
```

# Integration of 2019 data with 2017 data

```{r}
comnGenes <- intersect(
  rownames(dgeFilt), rownames(dgeFiltNhi)
)
```


## Set up DGE List and QC data

```{r}
# Combine counts into the same DGE List
# First extract counts from 2017 DGE List
countsNhi <- dgeListNhi$counts %>%
  as.data.frame() %>%
  rownames_to_column("Geneid") %>%
  as_tibble()
# Then join with 2019 counts
dgeListComb <- full_join(counts, countsNhi) %>%
  replace(is.na(.), 0) %>%
  as.data.frame() %>%
  dplyr::filter(Geneid %in% comnGenes) %>%
  column_to_rownames("Geneid") %>%
  DGEList() %>%
  calcNormFactors()
# Set group variable
dgeListComb$samples$group <- colnames(dgeListComb) %>%
  str_extract("(W|Q)") %>%
  factor(levels = c("W", "Q"))
```

```{r}
# Add genesGR to DGEList using rownames of DGEList to reorder the genesGR
dgeListComb$genes <- genesGR[rownames(dgeListComb),]
```

```{r}
# Create logical vector of genes to keep that fit criteria
genes2keepComb <- dgeListComb %>%
  cpm() %>%
  is_greater_than(1) %>%
  rowSums() %>%
  is_weakly_greater_than(8)
```

```{r}
# Create new DGEList of genes fitting criteria
dgeFiltComb <- dgeListComb[genes2keepComb,, 
                                   keep.lib.sizes = FALSE] %>%
  calcNormFactors()
```

```{r fig.align = "center"}
# Compare distributions of the DGELists before and after filtering
par(mfrow = c(1,2))
dgeListComb %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "Before Filtering")
dgeFiltComb %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = FALSE, main = "After Filtering")
par(mfrow = c(1,1))
```

## Differential Expression

```{r}
# Create model matrix
design <- model.matrix(~group, data = dgeFiltComb$samples)
```

```{r}
# Perform exact test on DGEList
topTableComb <- dgeFiltComb %>%
  estimateDisp(design = design) %>%
  exactTest() %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r fig.align = "center"}
# Volcano plot showing DE genes
topTableComb %>%
  ggplot(aes(logFC, -log10(P.Value), colour = DE)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(data = . %>% 
                    dplyr::filter(DE) %>%
                    dplyr::filter(-log10(P.Value) > 4 | abs(logFC) >                        2.5), aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey50", "red")) +
  labs(x = "logFC", y = expression(paste(-log[10], "(p)"))) +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
# Summary of DE genes
topTableCombDE <- topTableComb %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) 
topTableCombDE %>% pander(style = "rmarkdown", split.tables = Inf)
```

## LogFC Comparison

```{r}
# Extract logFC from topTables 
logFC <- topTable %>%
  dplyr::select(Geneid, Symbol, logFCNhi = logFC)
logFCNhi <- topTableNhi %>%
  dplyr::select(Geneid, Symbol, logFC)
# Join tables
logFCComb <- full_join(logFC, logFCNhi) %>%
  na.omit() 
```

```{r}
# Plot logFC graph
logFCComb %>%
  ggplot(aes(logFC,logFCNhi)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(
    aes(label = Symbol),
    data = . %>% 
      dplyr::filter(abs(logFC) > 2 | abs(logFCNhi) > 2) 
    ) +
  geom_abline(slope = 1, intercept = 0, col = "blue") +
  geom_vline(xintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  geom_hline(yintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  labs(x = "logFC (2019 dataset)", 
       y = "logFC (2017 dataset)") +
  xlim(-4, 6) + ylim(-4, 6) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

## Meta Analysis

### Hallmark

```{r}
# Extract p-values from 2017 and 2019 GSEA results and combine using Fisher's method
p2017Hallmark <- fgseaHallmarkNhi %>%
  dplyr::select(pathway, pval) %>%
  dplyr::mutate(pval = log10(pval)) %>%
  dplyr::rename(log10p2017 = pval)
p2019Hallmark <- fgseaHallmark %>%
  dplyr::select(pathway, pval) %>%
  dplyr::mutate(pval = log10(pval)) %>%
  dplyr::rename(log10p2019 = pval)
fgseaHallmarkMeta <- full_join(p2017Hallmark, p2019Hallmark) %>%
  replace(is.na(.), 0) %>%
  dplyr::mutate(
    chiSquare = -2 * (log10p2017 + log10p2019),
    pCombined = pchisq(chiSquare, df = 4, lower.tail = FALSE),
    FDR = p.adjust(pCombined, "fdr")
  ) %>%
  dplyr::arrange(pCombined)
```

### KEGG

```{r}
# Extract p-values from 2017 and 2019 GSEA results and combine using Fisher's method
p2017KEGG <- fgseaKEGGNhi %>%
  dplyr::select(pathway, pval) %>%
  dplyr::mutate(pval = log10(pval)) %>%
  dplyr::rename(log10p2017 = pval)
p2019KEGG <- fgseaKEGG %>%
  dplyr::select(pathway, pval) %>%
  dplyr::mutate(pval = log10(pval)) %>%
  dplyr::rename(log10p2019 = pval)
fgseaKEGGMeta <- full_join(p2017KEGG, p2019KEGG) %>%
  replace(is.na(.), 0) %>%
  dplyr::mutate(
    chiSquare = -2 * (log10p2017 + log10p2019),
    pCombined = pchisq(chiSquare, df = 4, lower.tail = FALSE),
    FDR = p.adjust(pCombined, "fdr")
  ) %>%
  dplyr::arrange(pCombined)
```

### Results

```{r}
# Hallmark
fgseaHallmarkMeta %>%
  dplyr::filter(FDR < 0.05) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched hallmark pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
# KEGG
fgseaKEGGMeta %>%
  dplyr::filter(FDR < 0.05) %>%
  pander(
    style = "rmarkdown", 
    split.tables = Inf, 
    justify = "lrrrrr", 
    caption = paste(
      "The", nrow(.), "most significantly enriched KEGG pathways.",
      "This corresponds to an FDR of", percent(max(.$FDR)))
  )
```

## PCA

```{r}
# Assess cpm values to make sure PCA results are not heavily skewed by highly expressed genes
pcaComb <- dgeFiltComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

```{r}
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaComb)$importance %>% pander(split.tables = Inf)
```

```{r fig.align = "center"}
# Create PCA plots
pca12 <- pcaComb$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFiltComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample, shape = data)) +
  geom_point(alpha = 0.8, size = 2) +
  # geom_text_repel(show.legend = FALSE) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaComb)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaComb)$importance[2,"PC2"]), ")"),
    colour = "Genotype",
    shape = "Dataset"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant")) +
  theme_bw() +
  theme(legend.position = c(1.2, 0.5))
pca13 <- pcaComb$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC3) %>%
  left_join(rownames_to_column(dgeFiltComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC3, colour = group, label = sample, shape = data)) +
  geom_point(alpha = 0.8, size = 2) +
  # geom_text_repel(show.legend = FALSE) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaComb)$importance[2,"PC1"]), ")"),
    y =  paste0("PC3 (", percent(summary(pcaComb)$importance[2,"PC3"]), ")")
  ) +
  theme_bw() +
  theme(legend.position = "none")
pca23 <- pcaComb$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC2, PC3) %>%
  left_join(rownames_to_column(dgeFiltComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC2, PC3, colour = group, label = sample, shape = data)) +
  geom_point(alpha = 0.8, size = 2) +
  # geom_text_repel(show.legend = FALSE) +
  labs(
    x = paste0("PC2 (", percent(summary(pcaComb)$importance[2,"PC2"]), ")"),
    y =  paste0("PC3 (", percent(summary(pcaComb)$importance[2,"PC3"]), ")")
  ) +
  theme_bw() +
  theme(legend.position = "none")
``` 

```{r}
# Set up grid for visualisation of 3 PCA's at once.
vp1 <- viewport(x = 0.25, y = 0.25, width = 0.5, height = 0.5)
vp2 <- viewport(x = 0.25, y = 0.75, width = 0.5, height = 0.5)
vp3 <- viewport(x = 0.75, y = 0.75, width = 0.5, height = 0.5)
# Plot PCA plots in grid
if (interactive()) grid::grid.newpage()
print(pca12, vp = vp1)
print(pca13, vp = vp2)
print(pca23, vp = vp3)
```

## RUVg

### Negative controls

```{r}
# Get genes that are common between the 10000 least DE genes of each dataset
negControlComb <- intersect(negControl, negControlNhi)
```

### k = 1

```{r}
# Run RUVSeq
RUVgComb_k1 <- RUVg(dgeFiltComb$counts, negControlComb, 1)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVgComb_k1$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgComb_k1 <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgComb_k1)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgComb_k1$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVgComb_k1)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVgComb_k1)$importance[2,"PC2"]), ")")
  ) +
  theme_bw()
```

### k = 2

```{r}
# Run RUVSeq
RUVgComb_k2 <- RUVg(dgeFiltComb$counts, negControlComb, 2)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVgComb_k2$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgComb_k2 <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgComb_k2)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgComb_k2$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVgComb_k2)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVgComb_k2)$importance[2,"PC2"]), ")")
  ) +
  theme_bw()
```

### k = 3

```{r}
# Run RUVSeq
RUVgComb_k3 <- RUVg(dgeFiltComb$counts, negControlComb, 3)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVgComb_k3$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgComb_k3 <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgComb_k3)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgComb_k3$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVgComb_k3)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVgComb_k3)$importance[2,"PC2"]), ")")
  ) +
  theme_bw()
```

### k = 4

```{r}
# Run RUVSeq
RUVgComb_k4 <- RUVg(dgeFiltComb$counts, negControlComb, 4)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVgComb_k4$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgComb_k4 <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgComb_k4)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgComb_k4$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVgComb_k4)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVgComb_k4)$importance[2,"PC2"]), ")")
  ) +
  theme_bw()
```

### k = 5

```{r}
# Run RUVSeq
RUVgComb_k5 <- RUVg(dgeFiltComb$counts, negControlComb, 5)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVgComb_k5$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVgComb_k5 <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVgComb_k5)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVgComb_k5$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVgComb_k5)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVgComb_k5)$importance[2,"PC2"]), ")")
  ) +
  theme_bw()
```

### Animation

```{r}
anim1 <- pcaRUVgComb_k1$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    ),
    k = "k = 1"
  )
anim2 <- pcaRUVgComb_k2$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    ),
    k = "k = 2"
  )
anim3 <- pcaRUVgComb_k3$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    ),
    k = "k = 3"
  )
anim4 <- pcaRUVgComb_k4$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    ),
    k = "k = 4"
  )
anim5 <- pcaRUVgComb_k5$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    ),
    k = "k = 5"
  )
```

```{r}
anim <- anim1 %>%
  full_join(anim2) %>%
  full_join(anim3) %>%
  full_join(anim4) %>%
  full_join(anim5) 
```

```{r}
anim <- anim %>%
  ggplot(
    aes_string(
      "PC1", "PC2", colour = "group", shape = "data"
    )
  ) +
  geom_point(size = 3, stroke = 0.5) +
  labs(colour = "Group", shape = "Dataset") +
  xlab(label = "PC1") +
  ylab(label = "PC2") +
  coord_cartesian(
    xlim = c(-100, 100),
    ylim = c(-50, 50)
    ) +
  transition_states(
    k,
    transition_length = 2,
    state_length = 3
  ) +
  ease_aes('cubic-in-out') +
  ggtitle("Now showing {closest_state}")
```

### DE Analysis

```{r}
# Create copy of DGE List 
dgeRUVgComb_k5 <- dgeFiltComb
# Bind W_1 from RUVSeq analysis to $samples 
dgeRUVgComb_k5$samples %<>% cbind(RUVgComb_k5$W)
# Create design matrix
design <- model.matrix(~group + W_1 + W_2 + W_3 + W_4 + W_5, data = dgeRUVgComb_k5$samples)
# Perform DE analysis
topTableRUVgComb_k5 <- estimateGLMCommonDisp(dgeRUVgComb_k5, design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef=2) %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r}
# Summary of DE genes
topTableRUVgComb_k5 %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR) %>% 
  pander(style = "rmarkdown", split.tables = Inf)
```

```{r}
# Check CPM values for DE genes
temp <- topTableRUVgComb_k5 %>%
  dplyr::filter(FDR < 0.05) %>%
  .$Geneid
```

### Gene removal

```{r}
# # Create table of gene GC content and length
# # This is extremely slow, takes approximately 30 minutes.
# # Saved as .rds file to save time
# id <- rownames(dgeRUVgComb_k3)
# geneGCLen <- getGeneLengthAndGCContent(id, org = "dre", mode = "biomart")
# saveRDS(geneGCLen, "../files/geneGCLen.rds")
```

```{r}
geneGCLen <- readRDS("../files/geneGCLen.rds") %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  as_tibble()
```

```{r}
# Filter for genes that have short length and high GC content.
# To be used for subsetting filtered dgeList
geneFilter <- geneGCLen %>%
  mutate(
    minLenTest = length > 1000,
    maxLenTest = length < 7600,
    gcTest = gc < 0.498
  ) %>%
  dplyr::filter(minLenTest, maxLenTest, gcTest)
```

```{r}
# Subset filtered dgeList
dgeRemoved <- dgeFiltComb[geneFilter$gene_id,]
```

#### PCA

```{r}
# Assess cpm values to make sure PCA results are not heavily skewed by highly expressed genes
pcaRemoved <- dgeRemoved %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

```{r fig.align = "center"}
# Create PCA plots
pcaRemoved$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeRemoved$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, label = sample, shape = data)) +
  geom_point(alpha = 0.8, size = 3) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRemoved)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRemoved)$importance[2,"PC2"]), ")"),
    colour = "Genotype",
    shape = "Dataset"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant")) +
  theme_bw()
```

## RUVs

```{r}
differences <- makeGroups(dgeFiltComb$samples$group)
```

```{r}
RUVsTest <- RUVs(dgeFiltComb$counts, negControlComb, k = 5, differences)
```

#### PCA

```{r}
# Create copy of dgeFilt as framework to replace RUVSeq results into
dgeFalseComb <- dgeFiltComb
# Replace with results
dgeFalseComb$counts <- RUVsTest$normalizedCounts
```

```{r}
# Run PCA function
pcaRUVs <- dgeFalseComb %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
# Quick inspection to check whether first two PCA components capture most of the variability
summary(pcaRUVs)$importance %>% pander(split.tables = Inf)
# Plot PCA
pcaRUVs$x %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  as_tibble() %>%
  dplyr::select(sample, PC1, PC2) %>%
  left_join(rownames_to_column(dgeFalseComb$samples, "sample")) %>%
  mutate(
    data = case_when(
      str_detect(.$sample, "_") == TRUE ~ "2017",
      str_detect(.$sample, "_") == FALSE ~ "2019"
    )
  ) %>%
  ggplot(aes(PC1, PC2, colour = group, shape = data)) +
  geom_point(size = 3, alpha = 0.8) +
  labs(
    x = paste0("PC1 (", percent(summary(pcaRUVs)$importance[2,"PC1"]), ")"),
    y =  paste0("PC2 (", percent(summary(pcaRUVs)$importance[2,"PC2"]), ")"),
    colour = "Genotype",
    shape = "Dataset"
  ) +
  scale_colour_discrete(labels = c("Wildtype", "Mutant")) +
  theme_bw()
```

### DE Analysis

```{r}
# Create copy of DGE List 
dgeRUVs <- dgeFiltComb
# Bind W_1 from RUVSeq analysis to $samples 
dgeRUVs$samples %<>% cbind(RUVsTest$W)
# Create design matrix
design <- model.matrix(~group + W_1 + W_2 + W_3 + W_4 + W_5, data = dgeRUVs$samples)
# Perform DE analysis
topTableRUVs <- estimateGLMCommonDisp(dgeRUVs, design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef=2) %>%
  topTags(n = Inf) %>%
  .$table %>%
  as_tibble() %>%
  unite("Range", ID.start, ID.end, sep = "-") %>%
  unite("Location", ID.seqnames, Range, ID.strand, sep = ":") %>%
  dplyr::select(
    Geneid = ID.gene_id, 
    Symbol = ID.gene_name,
    AveExpr = logCPM, logFC, 
    P.Value = PValue, 
    FDR, Location, 
    Entrez = ID.entrezid
  ) %>%
  mutate(DE = FDR < 0.05)
```

```{r}
# Summary of DE genes
topTableRUVsDE <- topTableRUVs %>%
  dplyr::filter(FDR < 0.05) %>%
  dplyr::select(Geneid, Symbol, AveExpr, logFC, P.Value, FDR)
topTableRUVsDE %>% 
  pander(style = "rmarkdown", split.tables = Inf)
```

```{r}
# Check CPM values for DE genes
DERUVs <- topTableRUVs %>%
  dplyr::filter(FDR < 0.05) %>%
  .$Geneid
dgeFiltComb$counts %>% cpm() %>% .[DERUVs,] %>% as.data.frame() %>% dplyr::select(str_subset(colnames(.), "Q.+"), str_subset(colnames(.), "W.+")) %>% round(digits = 2) %>% pander()
```

```{r}
# Volcano plot showing DE genes
topTableRUVs %>%
  ggplot(aes(logFC, -log10(P.Value), colour = DE)) +
  geom_point(alpha = 0.5) +
  # geom_text_repel(data = . %>% 
  #                   dplyr::filter(DE) %>%
  #                   dplyr::filter(-log10(P.Value) > 4 | abs(logFC) >                        2.5), aes(label = Symbol)) + 
  scale_colour_manual(values = c("grey50", "red")) +
  labs(x = "logFC", y = expression(paste(-log[10], "(p)"))) +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
# Test whether DE genes fall into bins of concern
GCLenTestComb <- tibble(DERUVs) %>%
  dplyr::rename(gene_id = DERUVs) %>%
  left_join(geneGCLen) %>%
  na.omit() %>%
  dplyr::mutate(
    minLenTest = length > 1000,
    maxLenTest = length < 7600,
    gcTest = gc < 0.498
  )
# Number of genes with length < 1000
GCLenTestComb %>%
  dplyr::filter(minLenTest) %>%
  nrow()
# Number of genes with length > 7600
GCLenTestComb %>%
  dplyr::filter(maxLenTest) %>%
  nrow()
# Number of genes with GC < 0.498
GCLenTestComb %>%
  dplyr::filter(gcTest) %>%
  nrow()
# Number of genes that satisfy all three criteria
GCLenTestComb %>%
  dplyr::filter(minLenTest, maxLenTest, gcTest) %>%
  nrow()
```

### GSEA

```{r}
# Create named vector of gene level statistics 
ranksRUVs <- topTableRUVs %>%
  mutate(stat = -sign(logFC) * log10(P.Value)) %>%
  dplyr::arrange(stat) %>%
  with(structure(stat, names = Geneid))
```

```{r}
# Set seed to enable reproducibility
set.seed(22)
# Run GSEA for hallmark
fgseaHallmarkRUVs <- fgsea(hallmark, ranksRUVs, nperm=1e5) %>%
  as_tibble() %>%
  dplyr::rename(FDR = padj) %>%
  mutate(padj = p.adjust(pval, "bonferroni")) %>%
  dplyr::arrange(pval)
```

